# -*- coding: utf-8 -*-
"""Multigrid_model_setup

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1amAyGaXrz4uMGMw6aZDNrkFZfSU1lp1a
"""

# Model setup
num_channel_input = 1
num_channel_u = 1
num_channel_f = 1
num_classes = 1 

J = 4 
num_iteration = [2,2,2,2] # multigrid. change this to [2,0,0,0] gives the gradient descent method
MG0=MG(num_channel_input, num_iteration, num_channel_u, num_channel_f, num_classes)

##PDE setup u=sin(2*pi*x)*sin(2*pi*y) 

N = 2 ** J -1
h = 1/2**J
u_exact = torch.ones(1,1,N,N)
f = torch.ones(1,1,N,N) / (N+1) **2


#Muligrid iteration 
M = 100
u = torch.randn(1,1,N,N)
error1 = [np.linalg.norm((A(u)-f).detach().numpy())]  # calculate the Frobenius Norm of (A*u-f)

for m in range(M):
    u_list = []                                      # Save u^0,u^1,u^2,u^3...,u^J
    u = MG0(u,f)
    for j in range(J-1,0,-1):
        u_list[j] += RT(u_list[j+1])
    u = u_list[1]
    error1.append(np.linalg.norm((A(u)-f).detach().numpy())) # calculate the Frobenius Norm of (A*u-f)