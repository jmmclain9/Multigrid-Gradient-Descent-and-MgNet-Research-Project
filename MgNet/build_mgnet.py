# -*- coding: utf-8 -*-
"""plot_numerical_solution

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1amAyGaXrz4uMGMw6aZDNrkFZfSU1lp1a
"""

minibatch_size = 8
num_epochs = 200
lr = 0.1/4

num_channel_input = 3
num_channel_u = 64 
num_channel_f = 64
num_classes = 10 
num_iteration = [2,2,2,2]

# define model
my_model = MgNet(num_channel_input, num_iteration, num_channel_u, num_channel_f, num_classes)
use_cuda = torch.cuda.is_available()
print('Use GPU?', use_cuda)

if use_cuda:
    my_model = my_model.cuda()

# define a loss function and training algorithm
criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(my_model.parameters(), lr=lr, momentum=0.9, weight_decay = 0.0005)


# load data, normalize CIFAR
normalize = torchvision.transforms.Normalize(mean=(0.4914, 0.4822, 0.4465), std=(0.2023, 0.1994, 0.2010))

transform_train = torchvision.transforms.Compose([torchvision.transforms.RandomCrop(32, padding=4),
                                                  torchvision.transforms.RandomHorizontalFlip(),
                                                  torchvision.transforms.ToTensor(),
                                                  normalize])

transform_test  = torchvision.transforms.Compose([torchvision.transforms.ToTensor(),normalize])


trainset = torchvision.datasets.CIFAR10(root='./data', train=True, download=True, transform=transform_train)
trainloader = torch.utils.data.DataLoader(trainset, batch_size=minibatch_size, shuffle=True)

testset = torchvision.datasets.CIFAR10(root='./data', train=False, download=True, transform=transform_test)
testloader = torch.utils.data.DataLoader(testset, batch_size=minibatch_size, shuffle=False)

# classes = ('plane', 'car', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck')



# training
epoch_list = []
test_acc_list = [] 
for epoch in range(num_epochs):
    epoch_list.append(epoch)

    current_lr = adjust_learning_rate(optimizer, epoch, lr)


    my_model.train()
    for i, (images, labels) in enumerate(trainloader):
        if use_cuda:
          images = images.cuda()
          labels = labels.cuda()

        # Forward pass to get the loss
        outputs = my_model(0,images)   # We need additional 0 input for u in MgNet
        loss = criterion(outputs, labels)
        
        # Backward and compute the gradient
        optimizer.zero_grad()
        loss.backward()  #backpropragation
        optimizer.step() #update the weights/parameters


  # compute training accuracy

    my_model.eval()
    correct = 0
    total = 0
    for i, (images, labels) in enumerate(trainloader):
        with torch.no_grad():
          if use_cuda:
              images = images.cuda()
              labels = labels.cuda()  
          outputs = my_model(0,images)  # We need additional 0 input for u in MgNet
          p_max, predicted = torch.max(outputs, 1) 
          total += labels.size(0)
          correct += (predicted == labels).sum()
    training_accuracy = float(correct)/total


    
    # compute test accuracy

    correct = 0
    total = 0
    for i, (images, labels) in enumerate(testloader):
        with torch.no_grad():
          if use_cuda:
              images = images.cuda()
              labels = labels.cuda()
          outputs = my_model(0,images)      # We need additional 0 input for u in MgNet
          p_max, predicted = torch.max(outputs, 1) 
          total += labels.size(0)
          correct += (predicted == labels).sum()
    test_accuracy = float(correct)/total
    test_acc_list.append(test_accuracy)

    
    print('Epoch: {}, lr: {},  train acc: {},  test acc: {}' .format(epoch+1,current_lr,training_accuracy,test_accuracy))